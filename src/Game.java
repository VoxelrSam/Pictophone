import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;

import org.json.simple.JSONObject;

/**
 * Class used to represent Games on the server
 * Handles all the game logic and keeping track of users
 * 
 * @author Samuel Ingram
 */
public class Game {
	
	/**
	 * HashMap of Game id's to Game objects to keep track of all games
	 */
	private static HashMap<String, Game> games = new HashMap<>();
	
	/**
	 * An ArrayList that holds the different pieces of data sent from the clients
	 * corresponding to each step in the game.
	 * i.e. holds both prompt strings and drawing data
	 */
	private ArrayList<String> timeline;
	
	private ArrayList<User> users;
	private User owner;
	private int size;
	private boolean isPublic;
	private String name;
	private String key;
	private String stage;
	private int promptCounter;
	private boolean booting;
	
	public Game(User owner, String name, int size, boolean isPublic) {
		this.owner = owner;
		this.name = name;
		this.size = size;
		this.isPublic = isPublic;
		this.key = Utils.generateWordKey();
		this.stage = "filling";
		this.promptCounter = 0;
		this.booting = false;
		
		games.put(this.key, this);
		
		users = new ArrayList<>();
		users.add(owner);
		owner.setGame(this);
		
		timeline = new ArrayList<>();
		
		if (isPublic)
			Game.pushGamesListUpdate();
		
		System.out.println("Game generated by " + owner.getName() + " of size " + size + " with id " + this.key);
	}
	
	/**
	 * Starts the game
	 */
	public void start() {
		this.stage = "playing";
		System.out.println("Game " + this.getKey() + " started!");
		
		// Randomize Order
		Collections.shuffle(users);
		
		// Set initial pages to send
		users.get(0).setStage("prompting");
		users.get(0).setPageUpdated(true);
		for (int i = 1; i < users.size(); i++) {
			if (!users.get(i).getStage().equals("waiting")) {
				users.get(i).setStage("waiting");
				users.get(i).setPageUpdated(true);
			}
		}
		
		// Send initial pages
		pushPages();
	}
	
	/**
	 * Ends the game. Normally called by the next() function
	 */
	private void end() {
		this.stage = "end";
		
		// Update each user's info
		for (int i = 0; i < users.size(); i++) {
			users.get(i).setStage("end");
			users.get(i).setPageUpdated(true);
			users.get(i).addGamesPlayed(1);
			
			if (users.get(i).isLoggedIn())
				DatabaseConnector.updateGamesPlayed(users.get(i));
		}
		
		// Send the ending pages
		pushPages();
	}
	
	/**
	 * Advances the game to the next stage
	 * i.e. prompts the next user
	 */
	private void next() {
		if (promptCounter + 1 == size) {
			end();
			return;
		}
		
		users.get(promptCounter).setStage("done");
		users.get(promptCounter).setPageUpdated(true);
		
		if ((++promptCounter) % 2 == 0)
			users.get(promptCounter).setStage("describing");
		else
			users.get(promptCounter).setStage("drawing");
		
		users.get(promptCounter).setPageUpdated(true);
		
		pushPages();
	}
	
	/**
	 * Handles game specific requests
	 * 
	 * @param request The request to be handled
	 * @param user The user to whom the request belongs
	 * @return 0 if success, 1 if otherwise
	 */
	public int handle(JSONObject request, User user) {
		switch ((String) request.get("type")) {
		case "getPage":
			
			return Utils.getPage(user);
		case "submitPrompt":
			timeline.add((String) request.get("prompt"));
			
			next();
			break;
		case "submitDrawing":
			timeline.add((String) request.get("image"));
			
			next();
			break;
		case "exit":
			user.leaveGame();
			
			return Utils.getPage(user);
		default:
			System.out.println("No Game case for request of type " + request.get("type"));
			return 1;
		}
		return 0;
	}
	
	/**
	 * Pushes updated pages to the users who are in a new stage
	 */
	private void pushPages() {
		for (User user : users) {
			if (user.pageUpdated()) {
				// Find page and send
				Utils.getPage(user);
				
				user.setPageUpdated(false);
			}
		}
	}
	
	/**
	 * Sends a message to all the users in the game
	 * 
	 * @param message the JSONObject representing the message to be sent
	 */
	public void sendToAll(JSONObject message) {
		for (User user : users) {
			user.send(message);
		}
	}
	
	/**
	 * Send an update of the user list to all the users in the game
	 */
	public void sendUsersUpdate() {
		JSONObject message = new JSONObject();
		message.put("type", "usersUpdate");
		message.put("users", this.getUsersString());
		message.put("roomsize", this.size);
		
		sendToAll(message);
	}
	
	/**
	 * Adds a user to the game, and sets the user's current game to this one
	 * Also starts game if the max amount of players join
	 * 
	 * @param u The user to be added
	 * @return 0 if success, 1 if otherwise
	 */
	public int addUser(User u) {
		if (users.size() == size || !stage.equals("filling"))
			return 1;
		
		users.add(u);
		u.setGame(this);
		
		if (users.size() == size)
			this.start();
		
		sendUsersUpdate();
		
		if (this.isPublic)
			Game.pushGamesListUpdate();
		
		return 0;
	}
	
	/**
	 * Remove the specified user from the game
	 * 
	 * @param u The user to remove
	 */
	public void removeUser(User user) {
		users.remove(user);
		user.setGame(null);
		
		if (this.owner != null && this.owner.equals(user))
			owner = null;
		
		// Kill the game if we lose too many
		if (users.size() < 3 && !booting) {
			killGame();
		}
	}
	
	/**
	 * Forcibly kill this game and boot all users
	 */
	public void killGame() {
		// Boot everyone out and remove the game
		if (!booting) {
			booting = true;
			
			JSONObject endMessage = new JSONObject();
			endMessage.put("type", "killGame");
			sendToAll(endMessage);
			
			// Make each user leave
			User user;
			while (!users.isEmpty()) {
				user = users.get(0);
				user.leaveGame();
			}
			
			System.out.println("Destroying game instance " + this.name);
			
			games.remove(this.key);
		}
	}

	public ArrayList<User> getUsers(){
		return users;
	}
	
	/**
	 * Get a String representing the users that is parsable by JavaScript
	 * 
	 * @return The parsable String
	 */
	public String getUsersString() {
		String ret = "[";
		
		for (User u : users) {
			ret += "\"" + u.getName() + ";" + u.getNameColor() + "\",";
		}
		
		ret = ret.substring(0, ret.length() - 1);
		ret += "]";
		
		return ret;
	}
	
	public ArrayList<String> getTimeline(){
		return timeline;
	}
	
	/**
	 * Get a String representing the timeline that is parsable by JavaScript
	 * 
	 * @return The parsable String
	 */
	public String getTimelineString() {
		String ret = "[";
		
		for (String s : timeline) {
			ret += "\"" + s + "\",";
		}
		
		ret = ret.substring(0, ret.length() - 1);
		ret += "]";
		
		return ret;
	}
	
	public int getSize() {
		return size;
	}
	
	public boolean isPublic() {
		return isPublic;
	}
	
	public String getName() {
		return name;
	}
	
	public String getKey() {
		return key;
	}
	
	public String getStage() {
		return stage;
	}
	
	public String getLastSubmission() {
		return timeline.get(promptCounter - 1);
	}
	
	public static Game getGame(String key) {
		return games.get(key);
	}
	
	/**
	 * Push an updated list of public games to all the users trying to join
	 */
	public static void pushGamesListUpdate() {
		JSONObject games = new JSONObject();
		games.put("games", Game.getPublicGames());
		games.put("type", "gamesListUpdate");
		
		ArrayList<User> joiningUsers = User.getJoiningUsers();
		
		for (User u : joiningUsers) {
			u.send(games);
		}
	}
	
	/**
	 * Get a String representing an array of all the public games
	 * 
	 * @return A String of games
	 */
	public static String getPublicGames() {
		String ret = "[";
		
		for (Game g : games.values()) {
			if (g.isPublic() && g.getStage().equals("filling"))
				ret += "\"" + g.getKey() + ";" + g.getName() + ";" + g.getUsers().size() + "/" + g.getSize() + "\",";
		}
		
		if (ret.length() != 1)
			ret = ret.substring(0, ret.length() - 1);
		
		ret += "]";
		
		return ret;
	}
}
